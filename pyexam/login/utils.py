"""An authentication function set.
"""
import datetime

from django.conf import settings
from django.contrib.auth import authenticate, get_user_model
from django.db.models import F, Sum
from django.template.loader import render_to_string
from django.utils import timezone
from django.utils.encoding import force_bytes, force_str
from django.utils.http import urlsafe_base64_decode, urlsafe_base64_encode

from rest_framework import serializers

from .models import ActiveCount, Profile
from .tokens import account_activation_token


def increase_login_count(user):
    """Used to increase the login count.

    Update data with consistent way.
    TODO: To avoid race condition
        Move the column to another model,
        and increase count with update method.

    Args:
        user(:obj: get_user_model): The user object.
    """
    user.login_count += 1
    user.save()


def update_social_name(backend, user, response, *args, **kwargs):
    """Used to set social name after social account login.

    After setting name,
    increase the login count
    and update the active day.
    Called from .settings.SOCIAL_AUTH_PIPELINE

    Args:
        user(:obj: get_user_model): The user object.
    """
    del backend, response, args

    if not user:
        return
    profile, _ = Profile.objects.get_or_create(user_id=user.id)
    if not profile.social_name:
        profile.social_name = kwargs.get('details').get('fullname')
        profile.save()
    increase_login_count(user)
    update_active_day(user)


def update_name(user, social_name):
    """Used to update the social name.

    Using update_or_create method to avoid race condition.

    Args:
        social_name: The name to update.

    Returns:
        True if update success.
        False if cannot get the user id to update.
    """
    if not user:
        return False
    Profile.objects.update_or_create(
        user_id=user.id,
        defaults={'social_name': social_name},
    )
    return True


def create_user_account(email, password):
    """Used to create account with email.

    Args:
        email: The user email.
        password: The user password.

    Returns:
        User object.
    """
    user = get_user_model().objects.create_user(email=email, password=password)
    user.backend = 'django.contrib.auth.backends.ModelBackend'
    user.email_confirmed = False
    user.is_social_auth = False
    user.save()
    return user


def get_and_authenticate_user(email, password):
    """Used to authenticate the user.

    Args:
        email: The user email.
        password: The user password.

    Returns:
        User object.

    Raises:
        ValidationError: If the email or password is not correct.
    """
    user = authenticate(username=email, password=password)
    if user is None:
        raise serializers.ValidationError(
            'Invalid username/password. Please try again!')
    return user


def send_verification_email(user):
    """Used to send email with verification information.

    Args:
        user(:obj: get_user_model): The user object.
    """
    current_site = f'{settings.FRONTEND_URL}:{settings.FRONTEND_PORT}'
    subject = 'Activate Your Account'
    message = render_to_string(
        'email/account_activation.html', {
            'user': user,
            'domain': current_site,
            'uid': urlsafe_base64_encode(force_bytes(user.pk)),
            'token': account_activation_token.make_token(user),
        })
    user.email_user(subject, message)


def activate_account(uidb64, token):
    """Activate account from email.

    Args:
        uidb64: The encoded value by user.pk
        token: A verified token generated by account_activation_token.

    Retruns:
        A tuple items forms by success and user.
        Index 0: True if activate successful.
        Index 1: User object if activate successful, otherwise None.
    """
    try:
        uid = force_str(urlsafe_base64_decode(uidb64))
        user = get_user_model().objects.get(pk=uid)
    except (TypeError, ValueError, OverflowError,
            get_user_model().DoesNotExist):
        return (False, None)

    if user is not None and account_activation_token.check_token(user, token):
        user.backend = 'django.contrib.auth.backends.ModelBackend'
        user.email_confirmed = True
        user.save()
        return (True, user)

    return (False, None)


def update_active_day(user):
    """Used to check or increase the counter for active user.

    Call by login.

    Args:
        user(:obj: get_user_model): The user object.
    """
    if not user:
        return
    profile = Profile.objects.get(user_id=user.id)
    today = timezone.now().date()
    if profile.last_active != today:
        _increame_active_count(today)
        profile.last_active = today
        profile.save()


def get_signed_up_user_amount():
    """Just return the number of signed up users.

    Used for the user statistics.

    Returns:
        the number of signed up users.
    """
    return get_user_model().objects.all().count()


def get_active_session_amount():
    """Just return the amount of today active user.

    Used for the user statistics.

    Returns:
        the amount of today active user.
    """
    today = timezone.now().date()
    record, _ = ActiveCount.objects.get_or_create(day=today)
    return record.count


def get_average_active_user_amount():
    """Return the average number of active session users

    Used for the user statistics.

    Returns:
        the average number of active session users.
    """
    today = timezone.now().date()
    period = today - datetime.timedelta(days=7)

    # Using Sum()/7 instead of Avg()
    # Because there is no data if one day without user login.
    # And then Avg() will divide by 6, not 7.
    #####
    # Another solution : Use cornroute to create default data.
    result = ActiveCount.objects.filter(day__gt=period).aggregate(Sum('count'))
    return result['count__sum'] / 7


def _increame_active_count(today):
    """Increase the active count.

    Using get_or_create and F() to avoid race condition.

    Args:
        today: The current date object.
    """
    record, _ = ActiveCount.objects.get_or_create(day=today)
    record.count = F('count') + 1
    record.save()
